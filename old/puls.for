c *****************************************************
      program puls
c******************************************************
c this program solves both the nonradial pulsation problem
c in the adiabatic cowling approximation and the
c purely radial adiabatic problem. we thank
c w. d. pesnell and p. jones for help in writing earlier
c versions of this code which solved the full fourth
c order system for adiabatic nonradial oscillations
c (plus quite a few other things).
c the input used is generated by the zams model builder.
c the method is to solve the two cowling approximation
c equations in their dziembowski form or the two
c purely radial equations by shooting from
c the center to the surface where, eventually and by
c iteration, the outer boundary conditions on the
c eigenfunctions are satisfied. the only guess you have
c to provide is that for the period (in seconds). you
c must also specify l which is angular momentum
c quantum number of the spherical harmonic function.
c enter a zero if you want the radial case.
c ******************************************************
      implicit double precision (a-h,o-z)
      common g(200),rho(200),x(200),yeig(2,200)
      double precision l,lhat,lindex
      common/misc/l,lhat,lindex,nsurf,period,grav,
     *    pi,pi4,p43,eps,verg,eig,eigt,nodes1,nodes2,
     *    modep
      logical radial
      common/rad/radial
      common/rs/r(200)
      common/flags/iprnt
c
c read in model quantities.
c
      call read
c
   10 write (6,2000)
 2000 format (' enter guessed period (in seconds)')
      write (6,2001)
 2001 format (' (enter a period of 0 to stop)')
      read (5,*) period
      if (period.ne.0.0d0) go to 20
      write (6,1000)
 1000 format (' calculation completed')
      stop
   20 write (11,1010) period
 1010 format (' guessed period=',1pe14.6,4h sec)
      eig=(2.d0*pi/period)**2
c eig is the first guess at the eigenvalue = sigma**2.
         eig = (2.0d0*pi/period)**2
         nconv = 0
         nserch=20
c
c try to converge to a solution using newton's method.
c
         do 70 ntry=1,nserch
            eigt=eig
            if (radial) then
               call goout0(disc)
            else
               call gooutl(disc)
            endif
c
c perturb eigenvalue and find change in boundary condition.
c disc is the boundary condition.
c
            eigt=(1.d0+eps)*eig
            if (radial) then
               call goout0(dum1)
            else
               call gooutl(dum1)
            endif
     	    deigd=dum1-disc
            deig=-disc*eps*eig/deigd
            write (6,1060) ntry,eig,deig
            write (11,1060) ntry,eig,deig
c deig is the predicted change in eig.
 1060 format(' ntry=',i3,' eig=',1pe15.7,' deig=',
     *         1pe13.5)
            adeig=dabs(deig/eig)
c check for convergence.
            if (adeig.lt.verg) nconv=1
c compute new guess for eig.
            epseig=deig/eig
            if (adeig.gt.0.1d0)
     *          epseig=0.1d0*deig/dabs(deig)
            eig=eig*(1.d0+epseig)
            if (nconv.eq.1) go to 80
   70    continue
         write (11,1080)
 1080 format (14h not converged)
         stop
c
c converged.
c
   80    eigt=eig
            if (radial) then
               call goout0(disc)
            else
               call gooutl(disc)
            endif
         period=(2.d0*pi)/dsqrt(eig)
         write ( 6,1090) period,eig
         write (11,1090) period,eig
 1090 format (' final values: period= ',1pe14.6,
     *      ' eig=',1pe17.9)
c count nodes in y1.
         call modeid
         if (radial) then
            write (6,1050) nodes1
            write (11,1050) nodes1
 1050 format (i3,' radial nodes in y1')
         else
            write (6,1110) nodes1,nodes2,modep
            write (11,1110) nodes1,nodes2,modep
 1110 format(i3,' nodes in y1   ',i3,' nodes in y2 '/
     @'     phase diagram mode ',i3)
         endif
         if (iprnt.ne.1) go to 140
         ysurf=yeig(1,nsurf)
         do 600 i=1,nsurf
             yeig(1,i)=yeig(1,i)/ysurf
             yeig(2,i)=yeig(2,i)/ysurf
  600 continue
         write (11,1130)
         write (11,1140) (i+1,r(i)/r(nsurf),yeig(1,i),
     *       yeig(2,i),i=1,nsurf)
 1130 format('                   2(n, r/r* ,  y1  ,  y2)')
 1140 format(2(i4,0pf10.6,2(1pe12.4)))
  140 continue
      go to 10
      end
c *****************************************************
c *****************************************************
      subroutine read
c  this routine reads in model quantities.
      implicit double precision (a-h,o-z)
      character*1 iyorn
      common g(200),rho(200),x(200),yeig(2,200)
      common/misc/l,lhat,lindex,nsurf,period,grav,
     *    pi,pi4,p43,eps,verg,eig,eigt,nodes1,nodes2,
     *    modep
      common/rs/r(200)
      common/flags/iprnt
      common /savel/m,xi(200),c1(4,200),y1(200),c2(4,200),
     @ y2(200),c3(4,200),y3(200),c4(4,200),y4(200),
     @ c5(4,200),y5(200),c6(4,200)
      common /surf/rsurf
      double precision l,lhat,lindex
      character*20 outfile, infile
      logical radial
      common/rad/radial
c
      radial=.false.
      write (6,*) ' your input filename is'
      read (5,3000) infile
 3000 format (a20)
      open (10,file=infile,status='unknown')
      write (6,*)  ' your output filename is '
      read (5,3000) outfile
      open (11,file=outfile,status='unknown')
      write (6,1080)
 1080 format (' enter l')
      read (5,*) l
      lhat=l*(l+1.d0)
      lindex=2.0d0-l
c setting up convergence criteria and eps for
c newton's method.
      verg=1.00d-05
      eps=1.00d-03
      pi=3.1415926535898d0
      p43=4.d0*pi/3.d0
      pi4=4.d0*pi
      grav=6.6723d-08
      read (10,*) amass
      read (10,*) xx,yy
      write (11,1000) amass
      write (6,1000) amass
 1000 format (' mass (in msun)=',0pf7.3)
      write (11,1001) xx,yy
      write (6,1001) xx,yy
 1001 format (' x=',0pf6.3,' y=', f6.3)
      write (11,1090) l
 1090 format (3h l=,0pf7.0)
c check to see if a purely radial calculation
c is to be done.
      if (l .lt. 0.9d0) radial=.true.
c read in model quantities from zams.
      read (10,*) nsurf
      read (10,*) (x(i),r(i),g(i),rho(i),i=1,nsurf)
      rsurf=r(nsurf)
      read (10,*) m
      do 100 i=1,m
           read (10,*) xi(i),y1(i),y2(i),y3(i)
           read (10,*) y4(i),y5(i)
  100 continue
      if (radial) then
c for the radial case y4 contains v (of the u-v plane)
c and y3 contains gamma1.
         do 101 i=1,m
           y4(i)=1.0d0/y5(i)-1.0d0
           y3(i)=y4(i)/y2(i)
  101    continue
      endif
c set up spline coefficients for use with integrator.
      call consl(xi,y1,m,c1)
      call consl(xi,y2,m,c2)
      call consl(xi,y3,m,c3)
      call consl(xi,y4,m,c4)
      call consl(xi,y5,m,c5)
      call consl(xi,r ,m,c6)
c do you want the eigenfunctions saved to file?
      write (6,2000)
 2000 format (' print out eigenfunctions (y/n)?')
      read (5,1100) iyorn
 1100 format (a1)
      if (iyorn.eq.'y'.or.iyorn.eq.'y') iprnt=1
      return
      end
c ******************************************************
c ******************************************************
      subroutine gooutl(b2)
c this controls the integration for the cowling
c approximation.
      implicit double precision (a-h,o-z)
      common g(200),rho(200),x(200),yeig(2,200)
      common/misc/l,lhat,lindex,nsurf,period,grav,
     *    pi,pi4,p43,eps,verg,eig,eigt,nodes1,nodes2,
     *    modep
      common/rs/r(200)
      double precision l,lhat,lindex
      common/splinq/vq(6)
      dimension y(2),work(50),iwork(6)
      external rkfcow
c
      yeig(1,1)=1.0d0
      yeig(2,1)=eigt/(l*grav*p43*rho(1))
      y(1)=yeig(1,1)
      y(2)=yeig(2,1)
      iflag=1
      neqn=2
      nsurf1=nsurf-1
   50 do 20 j=1,nsurf1
         k=j+1
         xstart=x(j)
         xfin=x(k)
         relerr=1.d-8
         abserr=dabs(y(1))
      do 30 i=2,neqn
         temp=dabs(y(i))
         abserr=dmin1(abserr,temp)
   30 continue
         abserr=1.d-8*abserr
         abserr=dmax1(abserr,1.d-20)
         call rkf(rkfcow,neqn,y,xstart,xfin,relerr,abserr,
     @        iflag,work,iwork)
         if (iflag.eq.3.or.iflag.eq.4.or.iflag.eq.5)
     @              write (11,1000) iflag,xfin
         iflag=1
         do 10 i=1,2
   10         yeig(i,k)=y(i)
   20 continue
      rt=x(nsurf)
      call splntl(rt,vq)
      temp=1.d0/vq(5)-1.d0
c the following is the outer boundary condition. we
c iterate until b2 is close enough to zero that
c corrections to the eigenvalue are within a small
c tolerance.
      b2=yeig(1,nsurf)*((4.d0+r(nsurf)*eigt/g(nsurf))
     @    /temp-1.d0)+(1.d0-lhat*g(nsurf)/r(nsurf)
     @   /eigt/temp)*yeig(2,nsurf)
 1000 format (17h watch out,iflag=,i4,6h xfin=,1pe10.2)
      return
      end
c ***************************************************
c ***************************************************
      subroutine goout0(b2)
c this controls the integration for purely
c radial pulsations.
      implicit double precision (a-h,o-z)
      common g(200),rho(200),x(200),yeig(2,200)
      common/misc/l,lhat,lindex,nsurf,period,grav,
     *    pi,pi4,p43,eps,verg,eig,eigt,nodes1,nodes2,
     *    modep
      common/rs/r(200)
      double precision l,lhat,lindex
      common/splinq/vq(6)
      dimension y(2),work(50),iwork(6)
      external rkfrad
c
      yeig(1,1)=1.0d0
      rt=x(1)
      call splntl(rt,vq)
      yeig(2,1)=-3.0d0*vq(3)*yeig(1,1)
      y(1)=yeig(1,1)
      y(2)=yeig(2,1)
      iflag=1
      neqn=2
      nsurf1=nsurf-1
   50 do 20 j=1,nsurf1
         k=j+1
         xstart=x(j)
         xfin=x(k)
         relerr=1.d-8
         abserr=dabs(y(1))
      do 30 i=2,neqn
         temp=dabs(y(i))
         abserr=dmin1(abserr,temp)
   30 continue
         abserr=1.d-8*abserr
         abserr=dmax1(abserr,1.d-20)
         call rkf(rkfrad,neqn,y,xstart,xfin,relerr,abserr,
     @        iflag,work,iwork)
         if (iflag.eq.3.or.iflag.eq.4.or.iflag.eq.5)
     @              write (11,1000) iflag,xfin
         iflag=1
         do 10 i=1,2
   10         yeig(i,k)=y(i)
   20 continue
      rt=x(nsurf)
      call splntl(rt,vq)
c the following is the outer boundary condition. we
c iterate until b2 is close enough to zero that
c corrections to the eigenvalue are within a small
c tolerance.
      b2=yeig(1,nsurf)*(4.0d0+eigt*r(nsurf)/g(nsurf))
     @   +yeig(2,nsurf)
 1000 format (17h watch out,iflag=,i4,6h xfin=,1pe10.2)
      return
      end
c ***************************************************
c ***************************************************
      subroutine rkfcow(rt,y,yp)
c
c this routine supplies the derivatives for use in rkf
c for the nonradial case.
c
      implicit double precision (a-h,o-z)
      common/misc/l,lhat,lindex,nsurf,period,grav,
     *    pi,pi4,p43,eps,verg,eig,eigt,nodes1,nodes2,
     *    modep
      double precision l,lhat,lindex
      dimension y(2),yp(2)
      common/splinq/vq(6)
      common /surf/rsurf
      call splntl(rt,vq)
c
      yp(1)=y(1)*(vq(2)-3.d0+lindex)+y(2)*(lhat*vq(1)
     @    /eigt-vq(2))
      yp(2)=y(1)*(eigt/vq(1)-vq(3))+y(2)*(1.d0-vq(4)
     @    +vq(3)+lindex)
      do 10 i=1,2
   10      yp(i)=yp(i)*vq(5)
      return
      end
c ****************************************************
c ****************************************************
      subroutine rkfrad(rt,y,yp)
c
c this routine supplies the derivatives for use in rkf
c for the radial case.
c
      implicit double precision (a-h,o-z)
      common/misc/l,lhat,lindex,nsurf,period,grav,
     *    pi,pi4,p43,eps,verg,eig,eigt,nodes1,nodes2,
     *    modep
      double precision l,lhat,lindex
      dimension y(2),yp(2)
      common/splinq/vq(6)
c
      call splntl(rt,vq)
      yp(1)=-(3.0d0*y(1)+y(2)/vq(3))
      yp(2)=vq(4)*(4.0d0*y(1)+eigt*y(1)/vq(1)+y(2))
      do 10 i=1,2
   10      yp(i)=yp(i)*vq(5)
      return
      end
c ****************************************************
c ****************************************************
      subroutine splntl(xint,yout)
c this subroutine interpolates model quantities for
c intermediate steps in the integration using cubic
c splines.
      implicit double precision (a-h,o-z)
      common/savngl/k,kq
      common /savel/m,x(200),c1(4,200),y1(200),c2(4,200),
     @   y2(200),c3(4,200),y3(200),c4(4,200),y4(200),
     @   c5(4,200),y5(200),c6(4,200)
      common/rs/y6(200)
      dimension yout(6)
c
      mm=m-1
      if (xint.ge.x(1).and.xint.lt.x(m)) go to 20
      if (xint .lt. (1.+1.d-8)*x(1)) go to 60
      if (xint .ge. x(m)) go to 10
      k=1
      go to 50
   10 if (xint .gt. (1.+1.d-6)*x(m)) go to 60
      k=mm
      go to 50
   20 il=1
      ir=m
   30 k=il+((ir-il)/2)
      if (xint.ge.x(k)) go to 40
      ir=k
      go to 30
   40 if (xint.lt.x(k+1)) go to 50
      il=k
      go to 30
   50 continue
      x1=x(k+1)-xint
      xx=xint-x(k)
      x12=x1*x1
      xx2=xx*xx
      yout(1)=x1*(c1(1,k)*x12 +c1(3,k))+xx*(c1(2,k)*xx2
     @    +c1(4,k))
      yout(2)=x1*(c2(1,k)*x12 +c2(3,k))+xx*(c2(2,k)*xx2
     @    +c2(4,k))
      yout(3)=x1*(c3(1,k)*x12 +c3(3,k))+xx*(c3(2,k)*xx2
     @    +c3(4,k))
      yout(4)=x1*(c4(1,k)*x12 +c4(3,k))+xx*(c4(2,k)*xx2
     @    +c4(4,k))
      yout(5)=x1*(c5(1,k)*x12 +c5(3,k))+xx*(c5(2,k)*xx2
     @    +c5(4,k))
      yout(6)=x1*(c6(1,k)*x12 +c6(3,k))+xx*(c6(2,k)*xx2
     @    +c6(4,k))
      return
   60 continue
      write (16,1000) xint
 1000 format (1h0,25hrange error in spline, x=,e15.6)
      stop
      end
c ***************************************************
c ***************************************************
      subroutine consl(x,y,m,c)
c this subroutine sets up coefficient arrays for spline
c interpolation.
c
      implicit double precision (a-h,o-z)
      dimension c(4,m)
      dimension x(m),y(m)
      dimension a(200,3),d(200),b(200),z(200),p(200)
c
      mm=m-1
      do 10 k=1,mm
           d(k)=x(k+1)-x(k)
           p(k)=d(k)/6.d0
   10      z(k)=(y(k+1)-y(k))/d(k)
      do 20 k=2,mm
           b(k)=z(k)-z(k-1)
  20       continue
      a(1,2)=-1.d0-d(1)/d(2)
      a(1,3)=d(1)/d(2)
      a(2,3)=p(2)-p(1)*a(1,3)
      a(2,2)=2.d0*(p(1)+p(2))-p(1)*a(1,2)
      a(2,3)=a(2,3)/a(2,2)
      b(2)=b(2)/a(2,2)
      do 30 k=3,mm
           a(k,2)=2.d0*(p(k-1)+p(k))-p(k-1)*a(k-1,3)
           b(k)=b(k)-p(k-1)*b(k-1)
           a(k,3)=p(k)/a(k,2)
           b(k)=b(k)/a(k,2)
   30 continue
      q=d(m-2)/d(m-1)
      a(m,1)=1.d0+q+a(m-2,3)
      a(m,2)=-q-a(m,1)*a(m-1,3)
      b(m)=b(m-2)-a(m,1)*b(m-1)
      z(m)=b(m)/a(m,2)
      mn=m-2
      do 40 i=1,mn
           k=m-i
           z(k)=b(k)-a(k,3)*z(k+1)
   40 continue
      z(1)=-a(1,2)*z(2)-a(1,3)*z(3)
      do 50 k=1,mm
           q=1.d0/(6.d0*d(k))
           c(1,k)=z(k)*q
           c(2,k)=z(k+1)*q
           c(3,k)=y(k)/d(k)-z(k)*p(k)
           c(4,k)=y(k+1)/d(k)-z(k+1)*p(k)
   50      continue
      return
      end
c ***************************************************
c ***************************************************
      subroutine modeid
c this subroutine identifies the mode of the pulsation
c using a phase diagram method. see unno et al. (1989).
      implicit double precision (a-h,o-z)
      common g(200),rho(200),x(200),yeig(2,200)
      double precision l,lhat,lindex
      common/misc/l,lhat,lindex,nsurf,period,grav,
     *    pi,pi4,p43,eps,verg,eig,eigt,nodes1,nodes2,
     *    modep
      integer quad,quad2,quad1
c
      modep=0
c first count the nodes in y1 and y2.
      nodes1=0
      nodes2=0
      do 10 i=2,nsurf
         fit1=yeig(1,i)*yeig(1,i-1)
         fit2=yeig(2,i)*yeig(2,i-1)
         if (fit1.le.0) nodes1=nodes1+1
         if (fit2.le.0) nodes2=nodes2+1
   10 continue
c count crossings in the phase diagram.
      quad1=quad(yeig(1,1),yeig(2,1))
      do 30 i=2,nsurf
         quad2=quad(yeig(1,i),yeig(2,i))
         idq=quad2-quad1
         if (idq.eq.0) go to 30
c see if quadrant chabge is a crossing in y1.
         if (iabs(idq).eq.3) go to 20
         if (quad1.eq.3.and.quad2.eq.2) go to 20
         if (quad1.eq.2.and.quad2.eq.3) go to 20
c not a y1 crossing.
         quad1=quad2
         go to 30
c if crossing is clockwise, increment mode count.
c if crossing is counterclockwise, decrement mode count.
   20    if (idq.eq.-3.or.idq.eq.1) kdmod=-1
         if (idq.eq.3.or.idq.eq.-1) kdmod=1
         modep=modep+kdmod
         quad1=quad2
c get next point.
   30 continue
      return
      end
c ****************************************************
c ****************************************************
      function quad(y1,y2)
c identifies the quadrant in the phase diagram
c used in modeid.
      implicit double precision (a-h,o-z)
      integer quad
c
      if (y1.gt.0.and.y2.ge.0) quad=1
      if (y1.le.0.and.y2.gt.0) quad=2
      if (y1.lt.0.and.y2.le.0) quad=3
      if (y1.ge.0.and.y2.lt.0) quad=4
      return
      end
c ****************************************************
c ********************************************************
      subroutine rkf(f,neqn,y,t,tout,relerr,abserr,
     @        iflag,work,iwork)
      implicit double precision (a-h,o-z)
      dimension y(neqn),work(1),iwork(5)
      external f
      k1m=neqn+1
      k1=k1m+1
      k2=k1+neqn
      k3=k2+neqn
      k4=k3+neqn
      k5=k4+neqn
      k6=k5+neqn
      call rkfs(f,neqn,y,t,tout,relerr,abserr,iflag,
     @    work(1),work(k1m),work(k1),work(k2),work(k3),
     @    work(k4),work(k5),work(k6),work(k6+1),
     @    iwork(1),iwork(2),iwork(3),iwork(4),iwork(5))
      return
      end
c------------------------------------------------------
c
      subroutine rkfs(f,neqn,y,t,tout,relerr,abserr,
     @    iflag,yp,h,f1,f2,f3,f4,f5,savre,savae,nfe,
     @    kop,init,jflag,kflag)
      implicit double precision (a-h,o-z)
      logical hfaild,output
      dimension y(neqn),yp(neqn),f1(neqn),f2(neqn),
     @    f3(neqn),f4(neqn),f5(neqn)
      external f
      data u26/2.d-13/ , remin/2.d-13/
      data maxnfe/3000/
      if (neqn .lt. 1) go to 10
      if ((relerr .lt. 0.d0)  .or.  (abserr .lt. 0.d0))
     @   go to 10
      mflag=iabs(iflag)
      if ((mflag .ge. 1) .and. (mflag .le. 7)) go to 20
   10 iflag=7
      return
   20 if (mflag .eq. 1) go to 50
      if (t .eq. tout) go to 10
      if(mflag .ne. 2) go to 25
      if (init .eq. 0) go to 45
      if (kflag .eq. 3) go to 40
      if ((kflag .eq. 4) .and.  (abserr .eq. 0.d0))
     @    go to 30
      if ((kflag .eq. 5)  .and. (relerr .le. savre)
     @    .and. (abserr .le. savae)) go to 30
      go to 50
   25 if (iflag .eq. 3) go to 40
      if ((iflag .eq. 4) .and. (abserr .gt. 0.d0))
     @    go to 45
   30 write (6,1000) iflag,t
 1000 format (16h rkf says iflag=,i5,3h x=,1pd12.4)
      stop
   40 nfe=0
      if (mflag .eq. 2) go to 50
   45 iflag=jflag
   50 jflag=iflag
      kflag=0
      savre=relerr
      savae=abserr
      rer=dmax1(relerr,remin)
      dt=tout-t
      if (mflag .eq. 1) go to 60
      if (init .eq. 0) go to 65
      go to 80
   60 init=0
      kop=0
      a=t
      call f(a,y,yp)
      nfe=1
      if (t .ne. tout) go to 65
      iflag=2
      return
   65 init=1
      ymax=0.d0
      ypn=0.d0
      do 70 k=1,neqn
        ypn=dmax1(dabs(yp(k)),ypn)
70      ymax=dmax1(dabs(y(k)),ymax)
      etn=rer*ymax+abserr
      h=dabs(dt)
      if(etn.ge.ypn*h**5) go to 80
      h=dmax1((etn/ypn)**0.2d0,u26*dmax1(dabs(t),h))
80    h=dsign(h,dt)
      if (dabs(h).ge.dabs(dt)) kop=kop+1
      if (kop.ne.100) go to 85
      iflag=6
      return
85    if (dabs(dt).gt.u26*dabs(t))go to 95
      do 90 k=1,neqn
90      y(k)=y(k)+dt*yp(k)
      a=tout
      call f(a,y,yp)
      nfe=nfe+1
      go to 300
95    output=.false.
      scale=2.d0/rer
      ae=scale*abserr
100   hfaild=.false.
      hmin=u26*dabs(t)
      dt=tout-t
      if (dabs(dt).ge.2.d0*dabs(h)) go to 200
      if (dabs(dt).gt.dabs(h)/0.9d0) go to 150
      output=.true.
      h=dt
      go to 200
150   h=0.5d0*dt
200   if (nfe.le.maxnfe) go to 220
      iflag=3
      kflag=3
      return
220   call fehl(f,neqn,y,t,h,yp,f1,f2,f3,f4,f5,f1)
      nfe=nfe+5
      eeoet=0.d0
      do 250 k=1,neqn
        et=dabs(y(k))+dabs(f1(k))+ae
        if (et.gt.0.d0) go to 240
        iflag=4
        kflag=4
        return
240     ee=dabs((-2090.d0*yp(k)+(21970.d0*f3(k)-15048.d0
     @     *f4(k)))+(22528.d0*f2(k)-27360.d0*f5(k)))
250     eeoet=dmax1(eeoet,ee/et)
      esttol=dabs(h)*eeoet*scale/752400.d0
      if (esttol.le.1.d0) go to 260
      hfaild=.true.
      output=.false.
      s=0.1d0
      if (esttol.lt.59049.d0)s=0.9d0/esttol**0.2d0
      h=s*h
      if (dabs(h).gt.hmin) go to 200
      iflag=5
      kflag=5
      return
260   t=t+h
      do 270 k=1,neqn
270     y(k)=f1(k)
      a=t
      call f(a,y,yp)
      nfe=nfe+1
      if (hfaild) go to 290
      s=5.d0
      if (esttol.gt.1.889568d-04) s=0.9d0/esttol**0.2d0
      h=dsign(dmax1(s*dabs(h),hmin),h)
290   if (output) go to 300
      if (iflag.gt.0) go to 100
      iflag=-2
      return
300   t=tout
      iflag=2
      return
      end
c-----------------------------------------------------
c
      subroutine fehl(f,neqn,y,t,h,yp,f1,f2,f3,f4,f5,s)
      implicit double precision (a-h,o-z)
      dimension y(neqn),yp(neqn),f1(neqn),f2(neqn),
     @   f3(neqn),f4(neqn),f5(neqn),s(neqn)
      ch=0.25d0*h
      do 10 k=1,neqn
   10      f5(k)=y(k)+ch*yp(k)
      call f(t+0.25d0*h,f5,f1)
      ch=0.09375d0*h
      do 20 k=1,neqn
   20      f5(k)=y(k)+ch*(yp(k)+3.d0*f1(k))
      call f(t+0.375d0*h,f5,f2)
      ch=h/2197.d0
      do 30 k=1,neqn
   30      f5(k)=y(k)+ch*(1932.d0*yp(k)+(7296.d0*f2(k)
     @     -7200.d0*f1(k)))
      call f(t+12.d0/13.d0*h,f5,f3)
      ch=h/4104.d0
      do 40 k=1,neqn
   40      f5(k)=y(k)+ch*((8341.d0*yp(k)-845.d0*f3(k))+
     @        (29440.d0*f2(k)-32832.d0*f1(k)))
      call f(t+h,f5,f4)
      ch=h/20520.d0
      do 50 k=1,neqn
   50    f1(k)=y(k)+ch*((-6080.d0*yp(k)+(9295.d0*f3(k)
     @     -5643.d0*f4(k)))+(41040.d0*f1(k)-28352.d0
     @     *f2(k)))
      call f(t+0.5d0*h,f1,f5)
      ch=h/7618050.d0
      do 60 k=1,neqn
   60     s(k)=y(k)+ch*((902880.d0*yp(k)+(3855735.d0
     @      *f3(k)-1371249.d0*f4(k)))+(3953664.d0*f2(k)
     @      +277020.d0*f5(k)))
      return
      end
c *************************************************
